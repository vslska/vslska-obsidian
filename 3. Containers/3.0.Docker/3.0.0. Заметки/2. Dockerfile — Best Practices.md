
###  1. Основные принципы

| Принцип | Почему важно | Пример |
|--------|--------------|--------|
| **Один процесс — один контейнер** | Масштабируемость, отказоустойчивость, логика | Не `nginx + php-fpm + redis` в одном — а три контейнера |
| **Идемпотентность сборки** | `docker build` → всегда один и тот же результат | Фиксированные теги (`alpine:3.19`, не `latest`) |
| **Минимализм слоёв** | Меньше слоёв = быстрее сборка, меньше дыр | Объединяй связанные команды через `&& \` |
| **Non-root по умолчанию** | Безопасность = свобода | `USER app` в конце, не `root` в продакшене |
| **.dockerignore** | Чистота контекста сборки | Исключи `node_modules/`, `.git/`, `*.log` |

---

### 2. Шаблон  Dockerfile (для Python-приложения)

```dockerfile
# 1. Стадия сборки (многостадийность — ключ к чистоте)
FROM python:3.11-slim AS builder

WORKDIR /app
COPY requirements.txt .
RUN pip wheel --no-cache-dir --no-deps --wheel-dir /wheels -r requirements.txt


# 2. Финальный образ — минималистичный, безопасный
FROM python:3.11-slim

# Создаём пользователя (non-root!)
RUN useradd --create-home --shell /bin/bash app
USER app
WORKDIR /home/app

# Копируем только wheels и код
COPY --from=builder /wheels /wheels
COPY --chown=app:app . .

# Устанавливаем зависимости (без build-зависимостей!)
RUN pip install --no-cache-dir --find-links /wheels --no-index -r requirements.txt \
    && rm -rf /wheels

# Точка входа — явно, с контрольными точками
CMD ["python", "app.py"]
```


> [!NOTE] Почему `slim` а не  `alipine`
> - `alpine`  использует `musl`, могут проблемы с `glibc` -  зависимыми библиотеками (например, `numpy`, `torch`).
> - `slim` - на `glibc`, стабильнее для production.
>    ( Ах да, да ты кто читатет это, если хочешь `alpine` тоже можно, добавь  `gcc musl-dev` во время сборки )


## 3.  Проверка качества.

| Иструмент  | Для чего                                    |                             |
| ---------- | ------------------------------------------- | --------------------------- |
| `hadolint` | Линтер Dockerfile (как `flake8` для Python) | `hadolint Dockerfile`       |
| `dive`     | Визуализация слоёв: размер, дубли, waste    | `dive my-image`             |
| `trivy`    | Сканирование уязвимостей в образе           | `trivy image my-app:latest` |

> [!NOTE] В CI/CD  -   можно добавить проверку.
> hadolint Dockerfile || echo "⚠️ Dockerfile needs love"
   trivy image --exit-code 1 --severity CRITICAL my-app:latest

## 4.  Docker-compose

Минимальный `docker-compose.yml` (v3.8)

```yaml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "8080:80"
    depends_on:
      - db
    environment:
      - DB_HOST=db
      - DEBUG=false
    volumes:
      - ./html:/usr/share/nginx/html:ro

  db:
    image: postgres:16
    environment:
      POSTGRES_DB: app
      POSTGRES_USER: app
      POSTGRES_PASSWORD: secret
    volumes:
      - db_data:/var/lib/postgresql/data

volumes:
  db_data:  # именованный том — данные переживут пересоздание контейнера

```

#### Полезные комманды

| Команда                                  | Описание                                                |
| ---------------------------------------- | ------------------------------------------------------- |
| `docker-compose up`                      | Запустить все сервисы (в foreground)                    |
| `docker-compose up -d`                   | В фоне                                                  |
| `docker-compose down`                    | Остановить + удалить контейнеры, сети (но **не тома!**) |
| `docker-compose down -v`                 | + удалить **тома** (осторожно! данные пропадут)         |
| `docker-compose build --no-cache`        | Пересобрать образы с нуля                               |
| `docker-compose logs -f web`             | Следить за логами сервиса `web`                         |
| `docker-compose exec db psql -U app app` | Подключиться к БД изнутри                               |
#### Сети и тома по умолчанию
- Каждый `docker-compose.yml` создаёт свою **отдельную сеть** (bridge). 
	`web` может обращаться к `db` просто по имени (`http://db:5432`).
- **Тома** (`volumes:`) живут в `/var/lib/docker/volumes/` — не в твоей домашней папке.  
	 Чтобы посмотреть: `docker volume inspect имя_проекта_db_data`

```yaml
networks:
  backend:
    driver: bridge

services:
  web:
    networks:
      - backend
```

#### `.env` — секреты вне кода

Создать `.env` (не коммитить в git)
```yaml
DB_PASSWORD=supersecret
DEBUG=true
```

Использовать в `docker-compose.yml`:
```yaml
environment:
  - POSTGRES_PASSWORD=${DB_PASSWORD}
  - DEBUG=${DEBUG}
```

Добавить в `.gitignore`
```gitignore
.env
*.env
```

#### Продвинутый lifehack :  `profiles` (для dev/prod)

```yaml
services:
  db:
    # …
  
  adminer:
    image: adminer
    ports: ["8081:8080"]
    depends_on: [db]
    profiles: ["debug"]  # запускается ТОЛЬКО при указании профиля

# Запустить с adminer:
# docker-compose --profile debug up
```

	В продакшене — чисто. В dev — удобно. Баланс.

- Не делать `docker-compose.yml` монстром на 200 строк.  
    → Разбить: `docker-compose.yml` (база) + `docker-compose.override.yml` (dev-only) + `docker-compose.prod.yml`.
- Не класть `docker-compose.yml` в корень репозитория, если проект не _про_ контейнеры.  
    → Лучше: `deploy/compose/` — как уважение к структуре.
- Использовать `docker-compose config` — чтобы проверить итоговый YAML _до_ запуска.
```bash
docker-compose -f docker-compose.yml -f docker-compose.prod.yml config
```