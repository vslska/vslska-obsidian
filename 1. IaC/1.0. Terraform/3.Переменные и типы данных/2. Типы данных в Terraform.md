Аргумент `type` в блоке переменных позволяет ограничить тип значения переменной. Если ограничение типа не установлено, то принимается значение любого типа — `any`.

> [!NOTE] Важно
> Ограничения типа данных (type constraints) необязательны, но мы рекомендуем указывать их. Они служат полезными напоминаниями для пользователей модуля и возвращают сообщение об ошибке, если используется неправильный тип данных.

Ограничения типа данных создаются из ключевых слов типа и конструкторов типов, позволяя комбинировать различные типы данных для описания сложных структур.

Типы данных можно разделить на primitive (простые) и complex (сложные):
![[Pasted image 20250923104530.png]]
## Простые типы данных
**String** — последовательность символов Unicode, представляющая текст (например, hello).
**Number** — числовое значение, которое может представлять целые числа (например, 15) и дробные значения (например, 6,283185).
**Bool** — логическое значение (**true** либо **false**), которое может использоваться в условной логике
## Сложные типы данных
**Коллекции** — для группировки схожих значений.
**Структурные типы** — для группировки потенциально несхожих значений.

Сложный тип данных группирует несколько значений в одно и представлен конструкторами типов. У некоторых конструкторов есть укороченные ключевые версии.
#### **Коллекции, или Collection**
Коллекции позволяют группировать несколько значений **одного** типа данных как одно значение. У всех типов коллекций должен быть элементный тип, который предоставляется как аргумент их конструктору. Например, `list(strings)` означает список строк, `list(numbers)` — список числовых значений.

> [!NOTE] Важно
Все элементы коллекции должны иметь один и тот же тип данных.
> 

Коллекции делятся на 3 группы

`list (...)` последовательность значений, которая идентифицируется последовательными целыми числами, начиная с 0.
- `list(string)` — список строк, например `["ru-central1-a", "ru-central-1b"]`.
- `list(number)` — список числовых значений, например `[4, 8, 15, 16, 23, 42]`.
- `list` или `list(any)` — принимает любой тип элемента, но все элементы должны иметь один тип данных. Например, вы можете присвоить значение `["abc", "def"]`, но не можете `["abc", 123]`.

`map (...)` коллекция значений, в которой каждое идентифицируется названием.
- `map(string)` — коллекция **ключ-значение строк**, например `{owner = "DevOps", project = "infra"}`.
- `map(number)` — коллекция **ключ-значение чисел**, например `{from_port: 8090, to_port = 8099}`.
- `map` или `map(any)` — принимает любой тип элемента, но все элементы должны иметь один тип данных. Например, вы можете присвоить значение `{abc = "abc", def = "def"}`, но не можете `{abc = "abc", def = 123}`.

`set (...)` коллекция уникальных значений, у которой нет последовательности или идентификации.
- `set(string)` — коллекция **строк**, например `["apple", "cherry", "banana"]`.
- `set(number)` — коллекция **чисел**, например `[101, 202, 303]`.
- `set` или `set(any)` — принимает любой тип элемента, но у всех элементов должен быть один тип данных. Например, вы можете присвоить значение `["abc", "def"]`, но не можете `["abc", 123]`.

#### **Структурные типы данных, или Structural**
Структурный тип позволяет группировать несколько значений различных типов данных в одно. Для структурных типов требуется схема в качестве аргумента, чтобы указать, какие типы данных разрешены для каждого элемента.

Структурные типы данных делятся на два вида:

`Object (...)`
Коллекция именованных атрибутов, у каждого есть свой тип данных. Схема объекта задаётся в виде `{KEY1 = TYPE, KEY2 = TYPE, ...}` — пар **ключ-значение**, разделённых запятой. Значение переменой должно содержать все указанные ключи, и значение для каждого ключа должно соответствовать его указанному типу.
```
type = object({
    cloud_name  = string
    name        = string
    description = string
    labels      = map(string)
  })
  
value = {
  cloud_name  = "Yandex Cloud"
  name        = "infra-folder"
  description = "Infrastracture"
  labels      = {
    environment = "production"
    owner       = "DevOps"
  }
}  
```

**Опциональные атрибуты типа данных `object(…)`**

Terraform возвращает ошибку, когда не получает значение всех атрибутов объекта. Это можно изменить, используя опциональные атрибуты.
Чтобы сделать атрибут объекта опциональным, используется конструкция `optional(<TYPE>, <DEFAULT>)`.

Она принимает два аргумента:
- `<TYPE>` — тип данных атрибута, обязательный аргумент.
- `<DEFAULT>` — значение по умолчанию, которое будет использоваться, если пользователь не передал атрибут или передал **null**. Если не указывать этот аргумент, будет использовано значение **null**.

В примере описана переменная для настроек PostgreSQL-кластера, все атрибуты объекта в ней опциональные и у них указано значение по умолчанию:
```
variable "performance_diagnostics" {
  description = "(Optional) - PostgreSQL cluster performance diagnostics settings."
  type = object({
    enabled                      = optional(bool, null)
    sessions_sampling_interval   = optional(number, 60)
    statements_sampling_interval = optional(number, 600)
  })
  default = {}
}
```

`tuple (...)`
Последовательность элементов, которая идентифицируется целыми числами, начиная с 0, при этом у каждого элемента свой тип данных. Схема кортежа задаётся в виде `[TYPE, TYPE, ...]` — списка типов, разделённых запятой. Значение переменной должно иметь то же количество и тип значений, что определены в схеме.
```
type = tuple(string, number, bool)

value = ["example", 42, true]
```
