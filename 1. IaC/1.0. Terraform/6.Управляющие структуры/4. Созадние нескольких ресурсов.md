, По умолчанию блок `resource` создаёт один элемент инфраструктуры. Однако может потребоваться управлять несколькими подобными объектами, например фиксированным пулом ВМ, не создавая отдельный блок для каждой из них. У Terraform есть два способа сделать это: `count` и `for_each`.
### Использование `count`
Если блок ресурса или модуля включает аргумент `count`, значение которого является целым числом, Terraform создаст указанное количество экземпляров.

Каждому экземпляру соответствует отдельный объект инфраструктуры, и каждый из них создаётся, обновляется или уничтожается отдельно при применении конфигурации.

В данном примере с помощью `count = 5` будет создано 5 ВМ:

```
resource "yandex_compute_instance" "this" {
    count = 5
    
  name        = "Server ${count.index}"
  platform_id = "standard-v1"
  zone        = "ru-central1-a"

  resources {
    cores  = 2
    memory = 4
  }

  boot_disk {
    initialize_params {
      image_id = "fd833v6c5tb0udvk4jo6"
    }
  }

  network_interface {
    subnet_id = yandex_vpc_subnet.this.id
  }
}
```

В блоках, где указан `count`, можно использовать атрибут `count.index` — целое число, начинающееся с `0` и соответствующее экземпляру.
В аргументе `count` можно использовать выражения. Например, таким образом добавляется опциональное создание ресурса:
```
count = var.enabled ? 1 : 0
```
Если переменная `enabled` будет равна `false`, ресурс не будет создан.
Использование `count = 0` позволяет избежать создание ресурса.

> [!NOTE] Важно
> Значение `count` должно быть известно до выполнения кода Terraform. Таким образом, нельзя использовать в качестве значения атрибуты, неизвестные до применения изменений.

Например, нельзя указывать:
```
count = yandex_compute_instance.this["ru-central1-a"].status == "Running" ? 1 : 0
```
Так как на момент применения изменений статус  ВМ  неизвестен.
```
The "count" value depends on resource attributes that cannot be determined until apply, so Terraform cannot predict how many       
instances will be created. To work around this, use the -target argument to first apply only the resources that the count depends  
on.
```

Terraform сообщит об ошибке и предложит в качестве обходного пути сначала создать зависимые ресурсы с помощью команды `terraform apply -target='yandex_compute_instance.this["ru-central1-a"]'`, а затем оставшиеся. Более правильным решением будет анализ и изменение кода для создания ресурса с учётом известных параметров, например на основе значений переменных.
##### **Обращение к экземпляру**
Если задано значение `count`, Terraform идентифицирует экземпляры с помощью индекса, начинающегося с `0`. Обращаться к конкретному экземпляру следует с помощью выражения:
```
<TYPE>.<NAME>[<INDEX>]
```

Например, для ВМ из примера выше это будет `yandex_compute_instance.this[0]`, `yandex_compute_instance.this[1]` и так далее.

> [!NOTE] Важно
> В качестве значения `count` можно использовать длину списка с помощью функции `length()` и обращаться к его значениям с помощью `count.index`. Такое использование `count` имеет значительный недостаток. Поскольку экземпляры ресурсов идентифицируются числовым индексом, при добавлении или удалении элемента в середине списка все последующие экземпляры ресурса будут затронуты этим изменением. В результате будет выполнено больше изменений, чем требуется.
##### **Когда лучше не использовать `count`**
Использование параметра `count` для управления количеством создаваемых экземпляров ресурса в Terraform может быть проблематичным при изменении индексов в списке. Когда вы добавляете или удаляете элемент в середине списка, происходит сдвиг индексов. Из-за этого все последующие ресурсы могут быть удалены и пересозданы, что вызовет перерывы в работе или потерю важных данных.
В этом примере используется `count` для создания нескольких экземпляров ВМ на основе длины списка `instance_names`:
```
# Переменная со списком названий серверов
variable "instance_names" {
  default = ["web-server", "app-server", "db-server"]
}

# Создание ресурса с использованием count
resource "yandex_compute_instance" "this" {
  count = length(var.instance_names)
  
  name = var.instance_names[count.index]
 
  ...
}
```

Проблема возникает, когда изменяется список, например при добавлении или удалении элемента. Если добавить новый сервер в середину списка, **все последующие ресурсы получат новые индексы, что может привести к их 
удалению и пересозданию**.
```
variable "instance_names" {
  default = ["web-server", "cache-server", "app-server", "db-server"]
}
```
Ресурс, который ранее был привязан к `app-server`, будет пересоздан, поскольку его индекс теперь другой. То же случится и с ресурсом `db-server`. **Если применить такие изменения, ВМ будут удалены и пересозданы!**

По этой причине использование `count` подходит только для определённых сценариев, где индексы не меняются или изменения в ресурсах не критичны. В большинстве случаев рекомендуется использовать `for_each`, поскольку он идентифицирует ресурсы по ключу, а не по индексу, что предотвращает нежелательное пересоздание ресурсов при изменении порядка элементов в списке.
Можно изменить приведённый выше код и использовать `for_each`, чтобы устранить проблему удаления и пересоздания ресурсов из-за замены индексов:
```
# Создание переменной с уникальными ключами для каждого экземпляра
variable "instance_map" {
  default = {
    "web" = "web-server",
    "app" = "app-server",
    "db"  = "db-server"
  }
}

# Использование for_each для создания ресурсов на основе переменной
resource "yandex_compute_instance" "this" {
  for_each = var.instance_map

  name = each.value
  
  ...
}

# Вывод, чтобы показать имена экземпляров
output "instance_tags" {
  value = [for k, v in var.instance_map : v]
}
```

### Использование `for_each`
Если ваши экземпляры практически идентичны, использование `count` уместно. Если некоторые из аргументов нельзя задать с помощью целых чисел `count.index`, то безопаснее использовать `for_each`. Он лишён недостатка `count`, поскольку экземпляры в нём идентифицируются строкой.
Аргумент `for_each` принимает типы данных `map` или `set(string)` и создаёт экземпляр для каждого элемента этих типов данных.

В примере ниже будут созданы две ВМ с итерацией по переменной `instances`:
```
variable "instances" {
  type = map(object({
    zone = string
    resources = object({
      cores  = number
      memory = number
    })
  }))
  default = {
    "server-1" = {
      zone = "ru-central1-a"
      resources = {
        cores  = 2
        memory = 2
      }
    }
    "server-2" = {
      zone = "ru-central1-b"
      resources = {
        cores  = 4
        memory = 4
      }
    }
  }
}

resource "yandex_compute_instance" "this" {
  for_each = var.instances

  name = each.key
  zone = each.value["zone"]
  resources {
    cores  = each.value.resources.cores
    memory = each.value.resources.memory
  }

...

}
```
В блоках, где установлено значение `for_each`, доступен дополнительный объект `each` в выражениях, позволяющий изменять конфигурацию каждого экземпляра. Этот объект имеет два атрибута:

- `each.key` — ключ `map` или `set`, соответствующий данному экземпляру;
- `each.value` — значение `map` или ключа `set`, соответствующее данному экземпляру.
```
Как и в случае с `count`, значение `for_each` должно быть известно до выполнения кода Terraform — нельзя использовать в качестве значения атрибуты, неизвестные до применения изменений.
```

Аргумент `for_each` можно использовать вместе с выражением `for` для обработки коллекций:
```
variable "databases" {
  description = "List of PostgreSQL databases."

  type = list(object({
    name                = string
    owner               = string
    lc_collate          = optional(string, null)
    lc_type             = optional(string, null)
    template_db         = optional(string, null)
    deletion_protection = optional(bool, null)
    extensions          = optional(list(string), [])
  }))
}

resource "yandex_mdb_postgresql_database" "database" {
  for_each = length(var.databases) > 0 ? { for db in var.databases : db.name => db } : {}

  name = each.value.name
...
}
```

```
variable "databases" {
  description = "List of PostgreSQL databases."

  type = list(object({
    name                = string
    owner               = string
    lc_collate          = optional(string, null)
    lc_type             = optional(string, null)
    template_db         = optional(string, null)
    deletion_protection = optional(bool, null)
    extensions          = optional(list(string), [])
  }))
}

resource "yandex_mdb_postgresql_database" "database" {
  for_each = length(var.databases) > 0 ? { for db in var.databases : db.name => db } : {}

  name = each.value.name
...
}
```
В примере выше будет создан ресурс типа `yandex_mdb_postgresql_database` для каждого из объектов в переменной.
### Обращение к экземпляру
Если задано значение `for_each`, то Terraform идентифицирует экземпляры с помощью ключа. Обращаться к конкретному экземпляру следует с помощью выражения:
```
<TYPE>.<NAME>[<KEY>]
```
Например, для ВМ из примера выше это будет `yandex_compute_instance.this["server-1"]`, `yandex_compute_instance.this["server-2"]` и так далее.