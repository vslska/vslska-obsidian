Некоторые типы ресурсов содержат повторяемые вложенные блоки в своих аргументах, обычно они представляют собой отдельные объекты.
```
resource "yandex_vpc_security_group" "this" {
...
  ingress {
    protocol       = "TCP"
    description    = "HTTP"
    v4_cidr_blocks = ["10.0.1.0/24"]
    port           = 80
  }
  
  ingress {
    protocol       = "TCP"
    description    = "HTTPS"
    v4_cidr_blocks = ["0.0.0.0/0"]
    port           = 443
  }  
...
}
```
Вы можете динамически конструировать вложенные блоки с помощью `dynamic`-блоков. Они поддерживаются внутри блоков `resource`, `data`, `provider` и `provisioner`.
Динамические блоки работают подобно `for_each`: итерируя по значению сложного типа данных, создают вложенные блоки.
В примере ниже создаются два блока `ingress`, аналогичные указанным выше, с итерацией по переменной `ingress_rules`.
```
variable "ingress_rules" {
  type = list(object({
    protocol       = string
    description    = string
    v4_cidr_blocks = list(string)
    port           = number
  }))
  default = [
    {
      protocol       = "TCP"
      description    = "HTTP"
      v4_cidr_blocks = ["10.0.1.0/24"]
      port           = 80
    },
    {
      protocol       = "TCP"
      description    = "HTTPS"
      v4_cidr_blocks = ["0.0.0.0/0"]
      port           = 443
    }
  ]
}

resource "yandex_vpc_security_group" "this"
...
  dynamic "ingress" {
    for_each = var.ingress_rules
    content {
      protocol       = ingress.value.protocol
      description    = ingress.value.description
      port           = ingress.value.port
      v4_cidr_blocks = ingress.value.v4_cidr_blocks
    }
...
}
```

В этом примере:
- Имя динамического блока `ingress` указывает, какой вид вложенного блока нужно создать.
- Аргумент `for_each` предоставляет значение для итерации.
- Вложенный блок `content` определяет содержимое каждого созданного блока.
В примере ниже блок `network_interface` имеет вложенный блок `dns_record`:
```
  dynamic "network_interface" {
    for_each = var.network_interfaces
    content {
      subnet_id          = network_interface.value.ubnet_id
      nat                = network_interface.value.nat
      nat_ip_address     = network_interface.value.nat_ip_address
      security_group_ids = network_interface.value.security_group_ids
      ip_address         = network_interface.value.ip_address

      dynamic "dns_record" {
        for_each = network_interface.value.dns_record
        content {
          fqdn        = dns_record.value.fqdn
          dns_zone_id = dns_record.value.dns_zone_id
          ttl         = dns_record.value.ttl
          ptr         = dns_record.value.ptr
        }
      }
    }
  }
```
При использовании вложенных динамических блоков особенно важно обращать внимание на итератор для каждого блока. В примере выше `network_interface.value` относится к текущему элементу внешнего блока, а `dns_record.value` — к текущему элементу внутреннего блока.

> [!NOTE] Важно
> Чрезмерное использование динамических блоков может затруднить чтение кода и поддержку конфигурации, поэтому рекомендуется использовать их только тогда, когда это необходимо. Пишите вложенные блоки явно, когда это возможно.

Если вам надо создать один блок без каких-либо дополнительных условий — не используйте динамический блок для этого:

```
variable "resources" {
...
  type = map(object({
    cores  = number
    memory = number
  }))
  default = {
    example = {
      cores  = 2
      memory = 4
    }
  }
}

resource "yandex_compute_instance" "this" {
...
  dynamic "resources" {
    for_each = var.resources
    content {
      cores  = resources.value["cores"]
      memory = resources.value["memory"]
    }
  }
...
}  
```

Укажите его в явном виде:

```
variable "cores" {
...
  type    = number
  default = 2
}

variable "memory" {
...
  type    = number
  default = 4
}

resource "yandex_compute_instance" "this" {
...
resources {
  cores  = var.cores
  memory = var.memory
}
...
}  
```
