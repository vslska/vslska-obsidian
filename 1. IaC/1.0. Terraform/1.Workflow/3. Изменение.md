1. **Изменение планов или требований**
Terraform позволяет легко адаптироваться к этим изменениям, модифицируя конфигурацию ресурсов.
2. **Оптимизация ресурсов для экономии затрат**
Ресурсы используются неэффективно, DevOps-инженер может изменить конфигурацию Terraform для оптимизации ресурсов и сокращения расходов.
3. **Масштабирование приложений**
Приложение становится популярным и требует больше ресурсов, чтобы обеспечить его производительность и доступность для растущего числа пользователей. DevOps-инженеры используют Terraform для добавления или увеличения ресурсов.
4. **Обновление или замена устаревших ресурсов**
Terraform позволяет обновить существующие ресурсы или заменить их на современные аналоги.
5. **Изменение провайдера облачных услуг**
Terraform облегчает миграцию ресурсов между облачными провайдерами.

Имена некоторых ресурсов должны быть уникальными. Автоматизировать процесс подбора уникального имени можно с помощью провадера  [[random]] .

Для изменения инфраструктуры нужно изменить код. Terraform поменяет только то, что нужно для достижения желаемого состояния инфраструктуры. Все изменения будут отражены в плане выполнения.

В зависимости от характера изменений они могут быть выполнены:
- **без пересоздания ресурсов, или in-place, — помечаются префиксом `~`;
- **с пересозданием ресурса — помечаются префиксом `-/+`.

![[Pasted image 20250921051320.png]]

Например, если увеличить размер диска существующей виртуальной машины с 15 до 20 ГБ и применить изменения, пересоздание ресурса не потребуется:
```hcl
resource "yandex_compute_disk" "boot_disk" {
  name     = "boot-disk"
  zone     = "ru-central1-a"
  image_id = "fd8ba9d5mfvlncknt2kd" # Ubuntu 22.04 LTS
- size     = 15
+ size     = 20
}
```

```bash
$ terraform apply

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  ~ update in-place

Terraform will perform the following actions:

  # yandex_compute_disk.boot_disk will be updated in-place
  ~ resource "yandex_compute_disk" "boot_disk" {
        id          = "fhmqfpe8r0bs91dnv7be"
        name        = "boot-disk"
      ~ size        = 15 -> 20
        # (9 unchanged attributes hidden)

        # (1 unchanged block hidden)
    }

Plan: 0 to add, 1 to change, 0 to destroy.
```

Если же изменить образ диска, потребуется пересоздание не только диска, но и виртуальной машины:
```hcl
resource "yandex_compute_disk" "boot_disk" {
  name     = "boot-disk"
  zone     = "ru-central1-a"
- image_id = "fd8ba9d5mfvlncknt2kd" # Ubuntu 22.04 LTS
+ image_id = "fd83hf0i4odnb7s2vnn8" # Centos 7
  size     = 15
}
```

```bash
$ terraform apply

Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
-/+ destroy and then create replacement

Terraform will perform the following actions:

  # yandex_compute_disk.boot_disk must be replaced
-/+ resource "yandex_compute_disk" "boot_disk" {
      ~ created_at  = "2024-03-12T15:35:45Z" -> (known after apply)
      ~ folder_id   = "b1g8lddqvv3e2h5oelo2" -> (known after apply)
      ~ id          = "fhmqfpe8r0bs91dnv7be" -> (known after apply)
      ~ image_id    = "fd8ba9d5mfvlncknt2kd" -> "fd83hf0i4odnb7s2vnn8" # forces replacement
      - labels      = {} -> null
        name        = "boot-disk"
      ~ product_ids = [
          - "f2esogi2vuuuj6uia832",
        ] -> (known after apply)
      ~ status      = "ready" -> (known after apply)
        # (4 unchanged attributes hidden)

      ~ disk_placement_policy {
          + disk_placement_group_id = (known after apply)
        }
    }

  # yandex_compute_instance.this must be replaced
-/+ resource "yandex_compute_instance" "this" {
      ~ created_at                = "2024-03-12T15:35:55Z" -> (known after apply)
      ~ folder_id                 = "b1g8lddqvv3e2h5oelo2" -> (known after apply)
      ~ fqdn                      = "fhmpa3frb975g8s2atqj.auto.internal" -> (known after apply)
      + gpu_cluster_id            = (known after apply)
      + hostname                  = (known after apply)
      ~ id                        = "fhmpa3frb975g8s2atqj" -> (known after apply)
      - labels                    = {} -> null
      + maintenance_grace_period  = (known after apply)
      + maintenance_policy        = (known after apply)
      - metadata                  = {} -> null
        name                      = "linux-vm"
      + service_account_id        = (known after apply)
      ~ status                    = "running" -> (known after apply)
        # (4 unchanged attributes hidden)

      ~ boot_disk {
          ~ device_name = "fhmqfpe8r0bs91dnv7be" -> (known after apply)
          ~ disk_id     = "fhmqfpe8r0bs91dnv7be" -> (known after apply) # forces replacement
          ~ mode        = "READ_WRITE" -> (known after apply)
            # (1 unchanged attribute hidden)

          ~ initialize_params {  # yandex_compute_instance.this must be replaced
​￼-/+ resource "yandex_compute_instance" "this" {
      ~ created_at                = "2024-03-12T15:35:55Z" -> (known after apply)
      ~ folder_id                 = "b1g8lddqvv3e2h5oelo2" -> (known after apply)
      ~ fqdn                      = "fhmpa3frb975g8s2atqj.auto.internal" -> (known after apply)
      + gpu_cluster_id            = (known after apply)
      + hostname                  = (known after apply)
      ~ id                        = "fhmpa3frb975g8s2atqj" -> (known after apply)
      - labels                    = {} -> null
      + maintenance_grace_period  = (known after apply)
      + maintenance_policy        = (known after apply)
      ​￼- metadata                  = {} -> null
        name                      = "linux-vm"
      + service_account_id        = (known after apply)
      ​￼~ status                    = "running" -> (known after apply)
        # (4 unchanged attributes hidden)

      ​￼~ boot_disk {
          ~ device_name = "fhmqfpe8r0bs91dnv7be" -> (known after apply)
          ~ disk_id     = "fhmqfpe8r0bs91dnv7be" -> (known after apply) # forces replacement
          ​￼~ mode        = "READ_WRITE" -> (known after apply)
            # (1 unchanged attribute hidden)

          ​￼~ initialize_params {
              ~ block_size  = 4096 -> (known after apply)
              + description = (known after apply)
              ~ image_id    = "fd8ba9d5mfvlncknt2kd" -> (known after apply)
              ~ name        = "boot-disk" -> (known after apply)
              ~ size        = 15 -> (known after apply)
              + snapshot_id = (known after apply)
              ~ type        = "network-hdd" -> (known after apply)
            }
    }-/+ 
              ~ block_size  = 4096 -> (known after apply)
              + description = (known after apply)
              ~ image_id    = "fd8ba9d5mfvlncknt2kd" -> (known after apply)
              ~ name        = "boot-disk" -> (known after apply)
              ~ size        = 15 -> (known after apply)
              + snapshot_id = (known after apply)
              ~ type        = "network-hdd" -> (known after apply)
            }
        }

      ~ metadata_options {
          ~ aws_v1_http_endpoint = 1 -> (known after apply)
          ~ aws_v1_http_token    = 2 -> (known after apply)
          ~ gce_http_endpoint    = 1 -> (known after apply)
          ~ gce_http_token       = 1 -> (known after apply)
        }

      ~ network_interface {
          ~ index              = 0 -> (known after apply)
          ~ ip_address         = "192.168.10.6" -> (known after apply)
          ~ ipv6               = false -> (known after apply)
          + ipv6_address       = (known after apply)
          ~ mac_address        = "d0:0d:19:50:df:b5" -> (known after apply)
          + nat_ip_address     = (known after apply)
          + nat_ip_version     = (known after apply)
          ~ security_group_ids = [] -> (known after apply)
            # (3 unchanged attributes hidden)
        }

      ~ placement_policy {
          ~ host_affinity_rules       = [] -> (known after apply)
          + placement_group_id        = (known after apply)
          ~ placement_group_partition = 0 -> (known after apply)
        }

      ~ resources {
          - gpus          = 0 -> null
            # (3 unchanged attributes hidden)
        }

      ~ scheduling_policy {
          ~ preemptible = false -> (known after apply)
        }
    }-/+ 

Plan: 2 to add, 0 to change, 2 to destroy.
```

Комментарий `# forces replacement` показывает, какое изменение приводит к пересозданию ресурса:
```
~ image_id    = "fd8ba9d5mfvlncknt2kd" -> "fd83hf0i4odnb7s2vnn8" # forces replacement
```
Если вы согласны с изменениями, подтвердите их, введя **yes,** как при создании ресурсов. Как указано в плане выполнения, Terraform сначала удалит существующие ресурсы, затем создаст новые. В последней строке будут указаны итоги выполнения:
```
yandex_compute_instance.this: Destroying... [id=fhmpa3frb975g8s2atqj]
yandex_compute_instance.this: Destruction complete after 45s
yandex_compute_disk.boot_disk: Destroying... [id=fhmqfpe8r0bs91dnv7be]
yandex_compute_disk.boot_disk: Destruction complete after 0s
yandex_compute_disk.boot_disk: Creating...
yandex_compute_disk.boot_disk: Creation complete after 11s [id=fhmu24qun3m258t6r16j]
yandex_compute_instance.this: Creating...
yandex_compute_instance.this: Creation complete after 23s [id=fhmtjpbs1bj8c1dttp3a]

Apply complete! Resources: 2 added, 0 changed, 2 destroyed.
```